[
{
	"uri": "/linux/compilelink/",
	"title": "Compile&amp;Link",
	"tags": [],
	"description": "",
	"content": "Compile \u0026amp; Link "
},
{
	"uri": "/linux/container/",
	"title": "Container",
	"tags": [],
	"description": "",
	"content": "Container Namespace, Cgroup\n"
},
{
	"uri": "/linux/container/namespace/",
	"title": "Namespace",
	"tags": [],
	"description": "",
	"content": "Namespace "
},
{
	"uri": "/linux/",
	"title": "Linux",
	"tags": [],
	"description": "",
	"content": "Linux The chapter that organizes information about Linux.\n"
},
{
	"uri": "/linux/container/namespace/1.what_is_namespace/",
	"title": "1. Namespace",
	"tags": [],
	"description": "",
	"content": "Namespace 기술은 cgourp(Control Group)과 함께 컨테이너(Container) 솔루션을 구성하는 기술 중 하나입니다. 이번 글에서는 namespcae에 대해 정리한 후linux에서 제공하는 namespcae의 종류에 대해 정리하고자 합니다.\nnamespace는 전역 시스템 리소스를 추상화하여 전역 리소스의 자체 격리 인스턴스가있는 namespace 내의 프로세스에 표시 되도록합니다. 전역 리소스에 대한 변경은 namespace의 멤버, 즉 동일한 namespace를 가진 다른 프로세스에서 볼 수 있지만 다른 namespace를 가진 프로세스에서는 보이지 않습니다. namespcae를 사용하는 것은 컨테이너를 구현하는 것입니다.\n   Namespace Constant Isolates     IPC CLONE_NEWIPC System V IPC, POSIX message queues   Network CLONE_NEWNET Network devices, stacks, ports, etc.   Mount CLONE_NEWNS Mount points   PID CLONE_NEWPID Process IDs   User CLONE_NEWUSER User and group IDs   UTS CLONE_NEWUTS Hostname and NIS domain name    namespace API namespace API에는 아래의 시스템 콜과 함께 /proc 파일이 포함됩니다. 먼저 system call에 대해 설명드립니다.\n시스템 콜    API Description     setns(2) setns 시스템 콜은 호출하는 프로세스가 존재하는 namespace에 조인합니다. 조인하고자 하는 namespace는 /proc/[pid]/ns 디렉토리 아래 존재하는 하나의 namespace 파일디스크립터(fd) 를 이용합니다.   clone(2) clone(2) 시스템 콜은 새로운 프로세스를 생성합니다. 시스템 콜 호출 시 flags argument로 CLONE_NEW* flag를 하나 이상 전달합니다. CLONE_NEW* flag는 위에서 설명한 바 있습니다. 그럼 각 flag에 해당하는 새로운 namespace가 생성되며 그 namepsaces의 멤버로 자식 프로세스가 생성됩니다.   unshare(2) unshare() 시스템 콜을 호출한 프로세스를 새로운 namespace로 이동시킵니다. 만약 flags argutment가 CLONE_NEW* flag를 입력한다면, 새로운 namespace가 생성되고, 해당 namespace의 멤버로 이동합니다.    여기서 유의할 점은 clone(2) 와 unshare(2) 시스템 콜을 사용하여 새로운 namespace들을 생성하기 위해선 CAP_SYS_ADMIN capability가 필요합니다. user namespace 생성은 예외적으로 privilege가 필요하지 않습니다.\n/proc/[pid]/ns 디렉토리 그럼 /proc 파일시스템에서 namespace에 대해 간략히 정리하겠습니다. 모든 프로세스들은 /proc/[pid]/ns 디렉토리가 존재합니다. 아래 ns 디렉토리에 여러 namespace가 존재하는 것을 확인할 수 있습니다. 이 namespace는 setns(2) 시스템 콜을 이용해 namespace를 변경하고자 할 때 변경을 원하는 namespace의 fd로 사용됩니다.\n$ ls -l /proc/$$/ns total 0 lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 ipc -\u0026gt; ipc:[4026531839] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 mnt -\u0026gt; mnt:[4026531840] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 net -\u0026gt; net:[4026531956] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 pid -\u0026gt; pid:[4026531836] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 user -\u0026gt; user:[4026531837] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 uts -\u0026gt; uts:[4026531838] 각 namespace 별 proc 파일은 다음과 같습니다.\n   namespace /proc file     IPC namespace /proc/[pid]/ns/ipc   Mount namespace /proc/[pid]/ns/mount   Network namespace /proc/[pid]/ns/net   PID namespace /proc/[pid]/ns/pid   User namespace /proc/[pid]/ns/user   uts namespace /proc/[pid]/ns/uts    Namespace 간략 정리 각 Namespace의 상세내용은 다른 글로 정리하고자 하며, 여기서는 간략하게 정리하고자 합니다.\nIPC namespace (CLONE_NEWIPC) IPC namespace는 특정 IPC 자원들(System V IPC,와 POSIX message queue)을 격리시킵니다. 특정 IPC 자원들의 공통적인 특징은 IPC 객체가 파일시스템 경로명 외의 메커니즘으로 식별된다는 것입니다. System V IPC에는 메시지 큐, 세마포어, 공유메모리를 가리킵니다.\nNetwork namespace (CLONE_NEWNET) Network namespace는 네트워크와 관련된 시스템 자원의 격리, 고립을 제공합니다. 해당되는 시스템 자원으로는 네트워크 디바이스들, IPv4, IPv6 프로토콜 스택, IP routing tables, 방화벽, /proc/net 디렉토리, /sys/class/net 디렉토리, 포트 번호 등등이 있습니다. 물리적 네트워크 장치는 정확히 하나의 네트워크 네임스페이스를 가질 수 있습니다. 가상 네트워크 장치는 네트워크 namespace 간에 터널을 생성하는데 사용할 수 있는 추상화된 파이프를 제공합니다.\nNetwork namespace가 해제되면, 물리 네트워크 장치는 초기 Network namespace로 변경됩니다. Network namespace를 사용하기 위해선 CONFIG_NET_NS 커널 옵션이 설정되어 있어야 합니다.\nMount namespaces (CLONE_NEWNS) Mount namespace는 파일시스템 마운트 지점의 집합을 고립, 격리합니다. 즉, 서로 다른 Mount namespace의 프로세스가 파일 시스템 구조에 대해 다른 뷰를 가질 수 있습니다. mount(2), umount(2) 를 이용해 Mount namespace 내에 마운트 집합들을 수정할 수 있습니다.\n/proc/[pid]/mounts 파일은 현재 프로세스의 Mount namespace에 마운트된 모든 파일시스템을 나열합니다. 이 파일의 포맷은 **fstab(5)**를 참고해주세요.\nseunghason@linuxias$cat /proc/self/mounts sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0 proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0 udev /dev devtmpfs rw,nosuid,relatime,size=16413672k,nr_inodes=4103418,mode=755 0 0 ... binfmt_misc /proc/sys/fs/binfmt_misc binfmt_misc rw,relatime 0 0 tmpfs /run/user/1000 tmpfs rw,nosuid,nodev,relatime,size=3288548k,mode=700,uid=1000,gid=1000 0 0 gvfsd-fuse /run/user/1000/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0 /proc/[pid]/mountstat 파일은 프로세스의 Mount namespace의 마운트 지점에 대한 정적, 설정 정보들을 보여줍니다. 보여지는 정보에 대한 것은 아래를 참고해주세요.\ndevice /dev/sda7 mounted on /home with fstype ext3 [statistics] ( 1 ) ( 2 ) (3 ) (4) The fields in each line are: (1) The name of the mounted device (or \u0026quot;nodevice\u0026quot; if there is no corresponding device). (2) The mount point within the filesystem tree. (3) The filesystem type. (4) Optional statistics and configuration information. Currently (as at Linux 2.6.26), only NFS filesystems export information via this field. PID namespace PID namespace는 프로세스 ID 공간을 격리 시킵니다. 이 말인 즉, 다른 PID namespace의 프로세스들은 같은 PID를 가질 수도 있음을 의미합니다. PID namespace들은 프로세스 집합의 종료, 재시작과 같은 기능을 제공하기 위한 컨테이너를 허용합니다. 또한 컨테이너를 새로운 호스트로 마이그레이션하는 등의 기능을 컨테이너가 제공할 수 있도록 해줍니다.\nPID namepsace의 특이한 점은 새로운 PID namespace의 PID는 1 부터 시작한다는 것입니다. standalone 시스템과 동일하게 각 namespace의 시작 프로세스는 pid를 1번을 가지게됩니다.\nPID namespace를 사용하기 위해선 CONFIG_PID_NS 커널 옵션을 설정해야 합니다.\nUser namespace User namespace는 시큐리티와 관련된 식별자 및 속성을 분리하며, 특히 User ID와 Group ID, 루트 디렉토리, Key, Capability를 분리합니다. 프로세스의 User, Group ID는 user namespace 내,외부적으로 다를수 있습니다. 특히 프로세스는 User namespace 외부에 권한이 없는 정상적인 User ID를 가질 수 있으며, 동시에 namepsace 내부에 User ID 0을 가질 수 있습니다. 즉, 프로세스에는 user namespace 내의 작업에 대한 전체 권한이 있지만 namespace 외부 작업에 대한 권한이 없습니다. 자세한 내용은 다른 글로 살펴보겠습니다.\nUTS namespace UTS namespace는 두개의 시스템 식별자를 고립, 격리시킵니다. 두 개의 시스템 식별자는 hostname과 NIS domain name입니다. 이 식별자들은 sethostname(2), **setdomainname(2)**으로 설정가능합니다. UTS namespace의 사용은 CONFIG_UTS_NS 커널 옵션을 설정해야 합니다.\n이상으로 Namespace에 대해 간단히 정리해보았습니다. 다음 글에서 각 namespace의 사용 및 예제에 대해 다뤄보겠습니다.\n감사합니다.\n감사합니다.\n"
},
{
	"uri": "/linux/container/namespace/2_pid_namespace/",
	"title": "2. PID Namespace",
	"tags": [],
	"description": "",
	"content": "PID namespace는 프로세스 ID 공간을 격리 시킵니다. 이 말인 즉, 다른 PID namespace의 프로세스들은 같은 PID를 가질 수도 있음을 의미합니다. PID namespace들은 프로세스 집합의 종료, 재시작과 같은 기능을 제공하기 위한 컨테이너를 허용합니다. 또한 컨테이너를 새로운 호스트로 마이그레이션하는 등의 기능을 컨테이너가 제공할 수 있도록 해줍니다.\nPID namepsace의 특이한 점은 새로운 PID namespace의 PID는 1 부터 시작한다는 것입니다. standalone 시스템과 동일하게 각 namespace의 시작 프로세스는 pid를 1번을 가지게됩니다. PID namespace를 사용하기 위해선 CONFIG_PID_NS 커널 옵션을 설정해야 합니다.\nThe namespace init process CLONE_NEWPID flag를 파라미터로 한 unshare(2) 시스템 콜을 호출한 이후, 또는 clone(2) 시스템 콜의 flag로 CLONE_NEWPID를 전달하여 생성한 프로세스는 새로운 Namespace의 첫 번째 프로세스가 됩니다. 이 말인 즉, 이 프로세스의 PID가 1번이라는 것입니다.\n조금 혼란스러울 수 있습니다. 리눅스에서 PID는 고유하며, 프로세스의 식별자로 사용이 되는데, 새로운 Namespace의 첫 번째 프로세스의 PID가 1번이라면, 중복될테니까요. 그 이후 이 프로세스에 자식 프로세스들도 2,3,4\u0026hellip; 와 같은 PID를 가질 수 있다는 말이됩니다. 식별자로써의 가치가 사라지게 되는 것일까요? 조금씩 정리해보도록 하겠습니다.\n새로운 PID namespace의 첫 번째 프로세스의 PID가 1번이라고 말씀드렸습니다. 그 의미는 해당 namespace를 위한 init process가 된다는 의미입니다. 아래 그림처럼 새로운 namespace는 PID 1번부터 시작하게 됩니다. 뭔가 속임수 같나요?\n그림 출처 : https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces\n만약 8,1 두 개의 PID를 가진 프로세스에서 getpid(2) 시스템 콜을 호출하게 되면, 어떤 결과가 리턴 될까요? 결과는 1입니다. PID를 이용해 동작하는 시스템 콜들은 항상 호출자의 PID namespace 내에 표시되는 PID를 사용하게 됩니다. 그렇기 때문에 child PID namespace에서 표시되는 1이 반환됩니다.\nnamespace 동작 중에 init process가 종료되면 어떻게 될까요? 만약 PID namespace 내의 init process가 종료된다면, 커널은 SIGKILL 시그널을 통해 해당 namespace 내에 모든 프로세스를 종료시키게 됩니다. 이 의미는 PID namespace가 정상적으로 동작하기 위해선 PID 1의 init process가 필수적이란 의미입니다.\ninit process에 시그널을 보낼 수 있는 경우는 시그널 핸들러에 등록한 시그널들만 PID namespace의 다른 프로세스들에 의해 전달될 수 있습니다. 이러한 제한은 권한이 있는 프로세스들에게도 해당되며 실수로 init process가 PID namespace 내의 다른 멤버 프로세스에 의해 종료되는 것을 막아주게됩니다. 마찬가지로 상위 PID namespace의 프로세스는 자식 PID namespace의 init process가 등록한 시그널 **kill(2)**을 호출하여 전달할 수 있습니다. 여기서 SIGKILL과 SIGSTOP은 예외적으로 처리되는데요, 상위 PID namespace에서 시그널을 전달하면 init process에서는 처리할 수 없기에, 해당 시그널이 처리되어 프로세스 종료 및 중지가 발생하게 됩니다.\nNesting PID namespace PID Namespace는 중첩해서 사용이 가능합니다. 그 말은, 각 PID namespace는 상위(부모) namespace를 가지고 있습니다.(root PID namespace는 제외입니다 :D) PID namepsace의 부모 namespace는 clone(2) 또는 **unshare(2)**를 사용하여 namespace를 생성한 프로세스의 PID namepsace가 됩니다. 이러한 구조는 PID namespace가 트리 자료구조 형태로 이루어져 있습니다. 모든 namepsace는 자신의 상위 namespace들(root namespace 포함)을 언제든 찾을 수 있습니다.\n특정 Namespace에 속한 프로세스는 해당 namespace에 속한 프로세스들과, 상위 모든(root namespace로 가는 경로의) namespace 프로세스들에게 보여집니다. 보여진다는 의미는 해당 프로세스를 타겟으로 작업을 진행할 수 있다는 의미입니다. 하지만 반대로 자식 PID namespace에서는 부모나 제거된 상위 namespace의 프로세스들을 볼 수 없습니다. 정리하면, 프로세스는 오직 자신의 PID namsepace의 프로세스들이나 자식 namespace들의 프로세스들만 볼 수 있습니다.\n특정 PID namespace내의 프로세스들은 가끔 namespace 외부에 부모 프로세스를 가지는 경우가 있습니다. 첫 번째는 위에서 살펴보았듯이, Namespace가 생성된 후 첫 프로세스는 자신을 생성한 프로세스가 부모프로세스가 됩니다. 이 경우엔 부모와 자식 프로세스가 각각 다른 PID namespace에 존재하게 됩니다. 두 번째로 setns(2) 시스템콜을 이용하여 특정 PID namespace로 조인하게 되는 경우입니다. 조인할 수 있는 PID namespace는 자식 PID namespace으로만 가능합니다. 완전 다른 방향의 namespace로는 불가능합니다. 잘 생각하셔야 할게 지금 설명드리는 부분은 namespace간 부모, 자식 관계가 아닌 프로세스의 부모, 자식 관계입니다.\n/proc 파일시스템과 PID namespace /proc 파일시스템은 /proc 파일시스템이 다른 Namespace에서 보여지더라도 마운트를 수행한 프로세스의 PID namespace에 보이는 프로세스만 보여줍니다. 새 PID namespace를 만든 후에는 ps (1)와 같은 툴이 정상적으로 작동하도록 /proc 파일시스템에 새로운 procfs 인스턴스를 마운트하고 루트 디렉토리를 변경하는 것이 좋습니다. clone (2) 또는 unshare(2)의 flags에 CLONE_NEWNS를 포함하여 새로운 마운트 네임 스페이스를 동시에 생성하면 루트 디렉토리를 변경할 필요가 없습니다. 새로운 procfs 인스턴스를 /proc에 직접 마운트 할 수 있습니다.\nmount -t proc proc /proc PID namespace는 container에서 유용하게 사용되는 기술 중 하나입니다. 추가적인 내용들은 정리되는대로 갱신하겠습니다. 글 읽어주셔서 감사합니다.\n감사합니다.\n참조 : https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces\n"
},
{
	"uri": "/linux/container/namespace/3.user_namespace/",
	"title": "3. User Namespace",
	"tags": [],
	"description": "",
	"content": " 먼저 이 글에서 사용한 코드는 linux kernel 4.16 임을 알려드립니다.\n User namespace는 시큐리티와 관련된 식별자 및 속성을 분리하며, 특히 User ID와 Group ID, 루트 디렉토리, Key, Capability를 분리합니다. 프로세스의 User, Group ID는 user namespace 내,외부적으로 다를수 있습니다. 특히 프로세스는 User namespace 외부에 권한이 없는 정상적인 User ID를 가질 수 있으며, 동시에 namepsace 내부에 User ID 0을 가질 수 있습니다. 즉, 프로세스에는 user namespace 내의 작업에 대한 전체 권한이 있지만 namespace 외부 작업에 대한 권한이 없습니다.\nNested namespaces, Namespace membership User namespace는 PID namespace 처럼 중첩되어 질 수 있습니다. 이 말은 root namespace를 제외하고 각 User namespace는 부모 user namespace를 가질 수 있다는 것입니다. 다른 관점에서 본다면 User namespace는 0개 또는 그 이상의 자식 User namespace를 가질 수 있습니다. 부모 User namespace는 CLONE_NEWUSER flag를 사용한 unshare(2) 또는 clone(2) 시스템콜을 통해 user namespace를 생성하는 프로세스의 namespace입니다. 음, 새로 생성된 namespace는 그 namespace를 생성하는 프로세스의 namespace를 부모 namespace로 가진다는 의미입니다.\n커널은 이렇게 중첩할 수 있는 user namespace의 레벨을 32개로 제한하고 있습니다.\n아래 struct user_namespace를 살펴보시죠. 아래 line.61에 int level; 구조체 멤버변수가 보이시나요? user namespace 는 이처럼 레벨을 관리하고 있습니다.\nFile path : include/linux/user_namespace.h 55 struct user_namespace { 56 struct uid_gid_map uid_map; 57 struct uid_gid_map gid_map; 58 struct uid_gid_map projid_map; 59 atomic_t count; 60 struct user_namespace *parent; 61 int level; 62 kuid_t owner; 63 kgid_t group; 64 struct ns_common ns; 65 unsigned long flags; 66 67 /* Register of per-UID persistent keyrings for this namespace */ 68 #ifdef CONFIG_PERSISTENT_KEYRINGS 69 struct key *persistent_keyring_register; 70 struct rw_semaphore persistent_keyring_register_sem; 71 #endif 72 struct work_struct work; 73 #ifdef CONFIG_SYSCTL 74 struct ctl_table_set set; 75 struct ctl_table_header *sysctls; 76 #endif 77 struct ucounts *ucounts; 78 int ucount_max[UCOUNT_COUNTS]; 79 } __randomize_layout; 만약 limit을 초과하게 되면 EUSERS 에러가 발생하게 됩니다.\n모든 프로세스들은 User namespace 중 하나에 속합니다. 여러분들이 프로세스 생성에 많이 사용하는 fork(2), **clone(2)**을 사용할 때 flag로 CLONE_NEWUSER를 전달하지 않는다면 해당 시스템 콜을 호출한 프로세스의 User namespace에 속하게 됩니다. 싱글스레드 프로세스는 setns(2) 시스템 콜을 사용하여 다른 user namespace로 포함될 수 있습니다. 조건은 setns(2) 시스템 콜을 호출하는 프로세스가 CAP_SYS_ADMIN Capability를 가지고 있어야 합니다.\n여기서 주의할 점은 멀티스레드 프로세스에서는 setns(2) 시스템 콜을 호출한 스레드만 namespace가 변경되어 버립니다. 그럼, 이상한 문제점들이 발생하게 될겁니다.\n하나의 스레드만 적용되는 이유는 아래 코드에서 확인할 수 있습니다. setns(2) 시스템 콜을 호출하게 되면 아래 함수가 수행됩니다. 여기서 line.268을 확인해보시면 현재 task_struct를 가져오게되고, line.283에서 task_struct를 가져와 namespace를 생성하게 되는데, 스레드는 각각의 task_struct를 가지고 있기에, 해당 thread에 대해서만 변경이 됩니다.\nFile path : kernel/nsproxy.c 266 SYSCALL_DEFINE2(setns, int, fd, int, nstype) 267 { 268 struct task_struct *tsk = current; 269 struct nsproxy *new_nsproxy; 270 struct file *file; 271 struct ns_common *ns; 272 int err; 273 274 file = proc_ns_fget(fd); 275 if (IS_ERR(file)) 276 return PTR_ERR(file); 277 278 err = -EINVAL; 279 ns = get_proc_ns(file_inode(file)); 280 if (nstype \u0026amp;\u0026amp; (ns-\u0026gt;ops-\u0026gt;type != nstype)) 281 goto out; 282 283 new_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk-\u0026gt;fs); 284 if (IS_ERR(new_nsproxy)) { 285 err = PTR_ERR(new_nsproxy); 286 goto out; 287 } 288 289 err = ns-\u0026gt;ops-\u0026gt;install(new_nsproxy, ns); 290 if (err) { 291 free_nsproxy(new_nsproxy); 292 goto out; 293 } 294 switch_task_namespaces(tsk, new_nsproxy); 295 296 perf_event_namespaces(tsk); 297 out: 298 fput(file); 299 return err; 300 } Capability CLONE_NEWUSER flag를 이용하여 clone(2) 시스템 콜로 생성된 자식 프로세스는 새로운 User namespace에서 완전한 Capability 집합을 가지고 실행됩니다. 마찬가지로 unshare(2), setns(2) 시스템 콜도 마찬가지로 Namepsace 내부에서 Capability의 전체 집합을 가지게 됩니다.\n반면에, 새로운 네임 스페이스가 생성 되더라도 그 프로세스는 부모 네임 스페이스 (클론 (2)의 경우) 또는 이전 (unshare(2) 및 **setns(2)**의 경우) User namepsace의 CCapability를 갖지 않습니다 또는 루트 사용자 (즉, Root User namepsace에서 사용자 ID가 0 인 프로세스)에 의해 조인됩니다.\n다른 경우로서, **execve(2)**를 호출하면 프로세스의 기능이 일반적인 방법으로 재계산됩니다 이 방식은 이 글의 범위를 벗어나기 때문에 다루지 않겠습니다. 관심있으신 분은 capabilites(7) 을 참조해주세요결과적으로 Namespace 내에 프로세스의 사용자 ID가 0이 아니거나 실행 가능 파일에 비어 있지 않은 상속 기능 마스크가 있으면 프로세스가 모든 기능을 잃게됩니다. 음, 자세한 내용은 아래에서 다시 다루겠습니다.\nclone(2) 또는 unshared(2) 를 이용해 새로운 IPC, mount, network, PID, UTS namespace를 생성할 때 커널은 새로운 Namespace에 대해 생성한 프로세스의 User namespace를 기록합니다. 새로운 Namespace의 프로세스가 나중에 Namespace 내에 격리된 전역 리소스에서 작동하는 권한 작업을 수행하면 커널이 새 Namespace와 연결된 User namespace의 프로세스 Capability에 따라 검사가 수행됩니다. 즉 Namepsace의 Capability는 User namespace와 상호작용하며 체크하게 된다는 것입니다.\nRestrictions on mount namespaces mount namespace 관련하여 정리한 내용입니다.\nmount namespace는 owner user namespace를 가지고 있습니다. owner user namespace가 상위 mount namespace의 owner user namespace와 다른 mount namespace는 권한이 낮은 mount namespace로 간주됩니다. 낮은 권한의 mount namespace가 생성될 때 공유 마운트는 슬레이브 마운트로 축소됩니다. 이렇게하면 권한이 낮은 mount namespace에서 수행 된 매핑이보다 많은 권한을 가진 mount namespace로 전파되지 않습니다.\n더 많은 권한을 가진 마운트에서 하나의 단위로 나오는 마운트는 함께 잠기고 특권이 적은 mount namespace에서 분리되지 않을 수 있습니다.\n파일 및 디렉토리에 대해서는 다른 namespace 마운트 지점이 아닌 하나의 namespace의 마운트 지점인 파일 또는 디렉터리는 마운트 지점이 아닌 mount namespace에서 이름을 변경하거나 연결 해제하거나 제거(rmdir(2))할 수 있다. 다른 mount namespace에서 마운트 포인트의 파일, 디렉토리를 삭제, rename, unlink를 시도하게 되면 EBUSY 에러가 나타납니다. 이런 결과는 특권이 많은 사용자로부터 DoS 공격을 막기 위한 방안입니다.\nInteraction of user namespaces and other types of namespaces User 네임스페이스는 다른 네임스페이스들과 연관관계를 맺고있습니다.\n리눅스 커널 3.8부터 권한이 없는(unprivileged) 프로세스들도 User 네임스페이스를 생성할 수 있습니다. 프로세스가 CAP_SYS_ADMIN Capability 를 가지고 있다면 Mount, PID, IPC, Network, UTS 네임스페이스도 생성할 수 있습니다.\nNon-user 네임스페이스(User 네임스페이스를 제외한 다른 네임스페이스)가 생성될 때 새로운 프로세스는 자신을 생성한 프로세스가 속한 User 네임스페이스에 속하게 됩니다. Non-user 네임스페이스은 User 네임스페이스의 기능이 필요합니다. 만약 ** clone(2) ** 또는 ** unshare(2) ** 호출 시 ** CLONE_NEWUSER ** 가 다른 ** CLONE_NEW* ** 플래그와 함께 명시된다면 User 네임페이스를 먼저 생성하게 됩니다. 그 이후 권한을 확인하여 나머지 네임스페이스의 생성을 하게 됩니다. 따라서 권한이 없는 호출 프로세스는 이와 같은 플래그의 조합으로 시스템 콜을 호출할 수 있습니다.\n새로운 IPC, mount, network, PID, UTS 네임스페이스가 ** clone(2) ** 또는 **unshare(2) ** 시스템 콜을 통해 생성되면 커널은 새로운 네임스페이스에 대해 생성되는 프로세스의 사용자 네임스페이스를 기록합니다. 새로운 네임스페이스의 프로세스가 네임스페이스 격리된 전역 리소스에서 동작하는 권한이 필요한 작업을 연속적으로 수행하면 커널이 새로운 네임스페이스와 연결된 User 네임스페이스의 새로운 프로세스 기능에 따라 권한을 검사하게 됩니다.\nUser 네임스페이스는 다른 네임스페이스들과 연관관계를 맺고 있는 부분을 확인 할 수 있으며, 특권(Capability)와 권한(Privilege)에 대한 관계도 관련이 있음을 알 수 있습니다.\nUser and Group ID mapplings : uid_map and gid_map User 네임스페이스가 생성되면 상위 User 네임스페이스에 User, Group ID가 매핑되지 않고 시작합니다. ** /proc/[pid]/uid_map ** 과 ** /proc/[pid]/gid_map ** 파일은 해당 프로세스의 User 네임스페이스 내부의 사용자와 그룹 ID 매핑 정보를 보여줍니다. 이 정보는 Namespace(1) 글에서 자료구조 내부적으로 어떻게 관리하는지 본 적이 있습니다.\n55 struct user_namespace { 56 struct uid_gid_map uid_map; 57 struct uid_gid_map gid_map; 58 struct uid_gid_map projid_map; 59 atomic_t count; 60 struct user_namespace *parent; 61 int level; 62 kuid_t owner; 63 kgid_t group; 64 struct ns_common ns; 65 unsigned long flags; 66 67 /* Register of per-UID persistent keyrings for this namespace */ 68 #ifdef CONFIG_PERSISTENT_KEYRINGS 69 struct key *persistent_keyring_register; 70 struct rw_semaphore persistent_keyring_register_sem; 71 #endif 72 struct work_struct work; 73 #ifdef CONFIG_SYSCTL 74 struct ctl_table_set set; 75 struct ctl_table_header *sysctls; 76 #endif 77 struct ucounts *ucounts; 78 int ucount_max[UCOUNT_COUNTS]; 79 } __randomize_layout; 위 구조체에서 uid_map, gid_map이 구조체의 멤버로 존재하며, user_namespace 구조체 내부에서 관리하고 있음을 알 수 있습니다.\n"
},
{
	"uri": "/linux/container/namespace/4.qemu/",
	"title": "4. QEMU",
	"tags": [],
	"description": "",
	"content": "Introduction QEMU는 고속의 동적 바이너리 변환 기법을 사용하는 프로세서 에뮬레이터이자 가상화 하이퍼바이저 입니다. 여기서 바이너리 변환이란 하나의 Instruction Set을 다른 Instruction Set으로 번환해주는 처리과정을 말하며, 정적 또는 동적인 방법이 존재합니다.\nQEMU에 대해 정리하기 앞서 QEMU와 KVM을 굉장히 많은 분들이 헷갈려 하시는데, 아래 블로그에 매우 자세하게 정리가 되어 있으니 참고하시면 좋을 것 같습니다.\n[Qemu와 KVM의 개념 - 에뮬레이션과 가상화][http://blog.naver.com/PostView.nhn?blogId=alice_k106\u0026amp;logNo=221179347223\u0026amp;parentCategoryNo=7\u0026amp;categoryNo=\u0026amp;viewDate=\u0026amp;isShowPopularPosts=true\u0026amp;from=search]\n이 글에서는 KVM이 아닌 QEMU에 관한 내용만 정리하려 합니다.\n처음 QEMU 개발 시에는 x86 기반이 아닌 아키텍처에서 x86 기반의 리눅스 응용 프로그램을 실행하는 목적으로 개발되었다고 합니다. 하지만 지금은 x86, ARM 등 다양한 아키텍처를 지원하고 있습니다.\nQEMU가 에뮬레이터로 사용될 때에는 특정 하드웨어 기반에서 실행 가능하도록 작성된 OS나 프로그램을 아키텍처의 변경없이 다른 하드웨어에서 실행되도록 하는 역할을 합니다. 하이퍼바이저로 사용될 때에는 KQEMU를 통해 게스트 OS의 코드를 호스트 시스템의 CPU에서 직접 실행하기 때문에 높은 성능이 발휘됩니다.\n또한 QEMU는 Xen 또는 KVM 하이퍼바이너의 가상화 기능을 도와주는 역할을 수행하기도 하는데, 이 경우 하드웨어 디바이스들의 에뮬레이터 기능을 수행하기 위해 변형된 형태의 QEMU 버전이 사용됩니다.\nArchitecture 하이퍼바이저에는 두 가지 타입이 있습니다. 베어메탈 (TYPE1)과 호스티드 (TYPE2) 방식입니다. 베어메탈 방식은 하드웨어 위에서 HOST OS없이 바로 실행되는 하이퍼바이저를 말하며, 호스티드 방식은 HOST OS 위에서 하이퍼바이저를 실행하여 GUEST OS를 실행하는 방식입니다. QEMU는 TYPE2 방식에 속합니다. QEMU는 두 가지 모드를 제공하고 있는데요, 전체 시스템 모드와 사용자 모드 에뮬레이션을 제공하고 있습니다. 전체 시스템 모드는 CPU 및 주변 장치들을 포함하는 전체 시스템을 에뮬레이션 합니다. 사용자 모드 에뮬레이션은 사용자가 특정 아키텍처에서 동작시키기 위해 크로스 컴파일 한 프로세스를 다른 아키텍처에서 실행할 수 있도록 해줍니다. 특정 프로그램만 빠르게 동작시켜보기 위해서는 사용자 모드를 사용하는게 편합니다.\nHypervisor QEMU는 KVM과 밀접한 관계가 있습니다. KVM은 리눅스 커널에 포함된 모듈로서 하이퍼바이저입니다. kVM 하이퍼바이저에서의 QEMU는 KVM에 최적화되어 변형된 버전인 ** qemu-kvm ** 이 실행되어서 x86 아키텍처에 대한 에뮬레이션을 제공합니다. QEMU는 호스트와 동일한 아키텍처의 OS를 실행하고자 할 떄만 KVM 가속화 기능을 사용합니다.\n"
},
{
	"uri": "/linux/container/namespace/5_mount_namespace/",
	"title": "5. Mount namespace",
	"tags": [],
	"description": "",
	"content": "mount namespace는 프로세스와 그 자식 프로세스에게 다른 파일시스템 마운트 포인트를 제공합니다. 각 namespace instance의 프로세스들에게 보여지는 마운트 포인트를 격리시키는 기능을 제공합니다. 이렇게 격리된 마운트 포인트는 각 프로세스에게 단일 디렉토리 구조로 보여지게됩니다.\n처음 설치된 시스템에서는 기본적으로 모든 프로세스가 하나의 mount namespaece(기본 namespace)에 속하기 때문에 파일시스템를 마운트하거나 해제하는 등의 모든 사항을 확인 및 인지할 수 있습니다.\nclone(2) 또는 unshare() 시스템 콜과 CLONE_NEWNS 플래그를 사용하여 새로운 프로세스를 생성하면 생성하는 프로세스의 mount namespace를 그대로 복사하여 생성하게 됩니다.\nmount의 종류 mount 할 때 private, shared, slave 옵션을 이용하여 mount를 할 수 있습니다. 각 방식의 차이는 아래와 같습니다.\n   mount 설명     private mount 각 마운트 포인트가 다른 마운트 포인트에 반영되지 않는 방법   shared mount 각 마운트 포인트가 다른 마운트 포인트에 반영되어 보여지는 방법(양방향)   slave mount A 파일시스템 하위에서 새로운 마운트는 B 파일시스템에 반영되나, 반대는 반영되지 않는 방법(단방향)    manual page를 검색하면 아래와 같이 나뉘어져 있습니다.\n source(A) shared private slave unbind ────────────────────────────────────────────────────────────────── dest(B) shared | shared shared slave+shared invalid nonshared | shared private slave unbindable  Restriction on mount namespace   mount namespace는 owner user namespace를 가지고 있습니다. 부모 mount namespace의 owner user namespace와 다른 mount namespace는 그 권한이 낮다고 판단할 수 있습니다.\n  권한이 낮은 mount namespace를 생성할 때, shared mount namespace는 slave mounts로 권한이 낮아집니다.\n  실습  임시 디렉토리를 생성한다.  linuxias$ mkdir /tmp/mount_ns unshare(1) 를 이용하여 새로운 bash 프로세스를 생성할 때 새로운 마운트 네임스페이스를 생성한다.  linuxias$ sudo unshare -m /bin/bash bash 프로세스가 별도의 네임스페이스에 속함을 확인한다. readlink 명령어를 이용해 네임스페이스의 inode 번호를 확인한다.  root# readlink /proc/$$/ns/mount mnt:[4026532199] 임시 마운트 지점을 생성하여 1번에서 생성한 디렉토리에 마운트 시킨다.  root# mount -n -t tmpfs tmpfs /tmp/mount_ns 새로 생성한 마운트 지점을 확인한다.  root# mount | grep mount_ns or root# cat /proc/mounts | grep mount_ns 새로운 터미널을 열고, 네임스페이스 inode를 확인한다.  linuxias$ readlink /proc/$$/ns/mount mnt:[4026531840] 새로운 터미널에서 마운트 지점을 확인한다.  linuxias$ mount | grep mount_ns or linuxias$ cat /proc/mounts | grep mount_ns 위 실습을 통해 알 수 있는 것은 새로 생성한 mount namespace 내에서 새로운 마운트 지점을 생성해도 기본 namespace에서는 알 수 없다는 것이다. 즉 독립화 되어 동작하게 됩니다.\n참고자료 및 문헌  Konstantin Ivanov | Containerization with LXC linux manual page - mount_namespace  "
},
{
	"uri": "/linux/container/namespace/6.uts_namespace/",
	"title": "6. UTS namespace",
	"tags": [],
	"description": "",
	"content": "UTS(Unix TimeSharing) namespace는 리눅스 컨테이너가 ** hostname -f ** 명령어에 의해 반환된 결과 값인 자신의 식별자를 유지관리하기 위해 hostname과 domainname을 namespace 별로 격리해줍니다. 격리하는 대상은 구별을 위한 식별자가 됩니다. 단순하게 생각하면 hostname은 호스트 각각의 이름이고 domainname은 그룹의 이름입니다. 기본적으로 domainname을 설정하지 않았다면 none으로 표시됩니다.\nUTS namespace로 분리할 수 있는 식별자는 sethostname(2)과 setdomainname(2)을 사용하여 설정되며 unname(2), gethostname(2) 및 getdomainname(2)을 사용하여 검색할 수 있습니다.\nunshare 또는 clone 시스템 콜 호출 시에 CLONE_NEWUTS 플래그를 사용하면 새로운 UTS namespace를 생성하고 해당 namespace를 가진 프로세스를 생성할 수 있습니다.\n실습  ** unshare ** 를 이용하여 새로운 UTS namespace를 만들어서 bash 프로세스를 실행합니다. 그 후 namespace를 변경합니다.   linuxias@linuxias-VirtualBox:~$ hostname linuxias-VirtualBox linuxias@linuxias-VirtualBox:~$ sudo unshare -u /bin/bash [sudo] password for linuxias: root@linuxias-VirtualBox:~# hostname linuxias-VirtualBox root@linuxias-VirtualBox:~# hostname uts-namespace root@linuxias-VirtualBox:~# hostname uts-namespace root@linuxias-VirtualBox:~# cat /proc/sys/kernel/hostname uts-namespace root@linuxias-VirtualBox:~# 새로운 터미널 세션을 생성하여 hostname을 확인해봅니다. hostname이 설정 전의 hostname임을 확인할 수 있습니다.  linuxias@linuxias-VirtualBox:~$ hostname linuxias-VirtualBox 참고자료 및 문헌  Konstantin Ivanov | Containerization with LXC linux manual page - namespace, hostname  "
},
{
	"uri": "/linux/container/namespace/7.cgroup_namespace/",
	"title": "7. Cgroup Namespace",
	"tags": [],
	"description": "",
	"content": "cgroup namespace는 프로세스의 cgroups의 뷰를 가상화 합니다.\n각 cgroup 네임스페이스에는 고유한 cgroup 루트 디렉토리 세트가 있습니다. 그 루트 디렉토리는 /proc/[pid]/cgroup 파일의 해당 레코드에 표시되는 상대 위치의 베이스 위치입니다. clone(2) 또는 unshare(2) 시스템 콜에 CLONE_NEWCGROUP 플래그를 전달하여 새로운 cgroup namespace를 생성할 수 있습니다. 이렇게 생성된 namespace는 현재 cgroups 디렉토리가 새 namespace의 cgroup 루트 디렉토리가되는 새 cgroup namespace로 들어갑니다. 이 정책은 cgroup 버전 1,2 모두에 적용됩니다.\n/proc/[pid]/cgroup 을 확인하면 표시되는 각 레코드의 세 번째 필드에 표시된 경로 이름은 해당 cgroup 계층에 대한 읽기 프로세스의 루트 디렉토리에 상대적인 위치입니다.\ncat /proc/$$/cgroup 12:pids:/user.slice/user-1000.slice/session-2.scope 11:memory:/ 10:cpuset:/ 9:hugetlb:/ 8:blkio:/ 7:freezer:/ 6:cpu,cpuacct:/ 5:devices:/user.slice 4:perf_event:/ 3:net_cls,net_prio:/ 2:rdma:/ 1:name=systemd:/user.slice/user-1000.slice/session-2.scope 0::/user.slice/user-1000.slice/session-2.scope 만약 해당 프로세스의 cgroup 디렉토리가 읽은 프로세스의 cgroup namespace의 외부에 위치한다면 경로는 ../ 와 같이 cgroup 구조에서 상위 레벨로 표시될 것 입니다.\n"
},
{
	"uri": "/linux/compilelink/gcc_warning_option/",
	"title": "[gcc] Warning 옵션",
	"tags": [],
	"description": "",
	"content": "gcc 컴파일 옵션으로 많이 사용하는 -Wall , -Wextra 이외에 다양한 옵션들은 정리하고자 합니다.\n   옵션 설명 특이사항     -fstack-usage 컴파일러가 프로그램에 대한 스택 사용 정보를 함수 단위로 출력하도록 합니다. 함수의 이름, 바이트 수 등이 표기됩니다. x   -Wframe-larger-than={len} 함수 프레임의 크기가 len을 넘어가면 Warning이 출력합니다. x   -Wstrict-overflow=n -fstrict-overflow가 활성화 되어있는 경우에만 활성화됩니다. 컴파일러가 signed 오버플로우가 일어나지 않을거라 가정하고 최적화를 진행하는 경우에 Warning이 발생합니다. Wall에 포함 (-Wstrict-overflow=1)   -Wlogical-op 표현식에서 논리연산자의 사용에 대해 문제가 발생할 수 있는 경우 Warning을 발생합니다. x   -Wjump-misses-init goto문을 통해 변수 초기화 이전으로 분기하거나, 변수가 초기화된 이후로 분기하는 것을 Warning이 발생합니다. C, Objective-C only   -Wmissing-include-dirs 사용자 제공 include 디렉토리가 존재하지 않으면 Warning이 발생합니다. C/C++, Obj C/C++ only   -Wunused 여러 unused 옵션(unused-but-set-parament, unused-but-set-variable, unused-function, unused-label, unused-local-typedefs, unused-parameter, -no-unused-result, unused-variable, unused-value)을 한 번에 포함하는 옵션입니다. 사용되지 않는 함수 매개 변수에 대한 경고를 얻으려면 -Wextra -Wunused (-Wall implies -Wunused)를 지정하거나 -Wunused-parameter를 별도로 지정해야합니다 Wall에 -Wunused-function -Wunused-label -Wunused-value -Wunused-variable 옵션이 포함되어 있습니다.   -Wpacked-bitfield-compat 4.1, 4.2 및 4.3 계열의 GCC는 \u0026ldquo;char\u0026quot;유형의 비트 필드에서 \u0026ldquo;packed\u0026quot;속성을 무시합니다. GCC 4.4에서 그러한 필드의 오프셋이 변경되면 GCC에서 알려줍니다. Default enable   -Winvalid-pch precompile된 헤더가 검색 경로에서 찾았으나 사용하지 못하는 경우 Warning이 발생합니다. -   -Wstack-protector Stack smashing으로부터 보호되지 않는 경우 Warning이 발생합니다. Stack smashing protector(SSP) 기능은 -fstack-protector 옵션을 사용해야 합니다. SSP 는 함수 진입 시 스택에 return address와 frame pointer 정보를 저장할 때 이 정보를 보호하기 위해 (canary라고 부르는) 특정한 값을 기록해두고 함수에서 반환할 때 기록된 값이 변경되지 않았는지 검사하여 정보의 일관성을 관리합니다. 만약 악의적인 사용자가 buffer overflow 등의 공격을 통해 스택 내의 정보를 덮어쓰려면 canary 값을 먼저 덮어써야 하기 때문에 canary 값 만 보면 공격이 일어났는지를 알 수 있습니다. -fstack-proctector가 활성화 된 경우 활성화 됩니다.   -Wunused-variable 지역변수 또는 상수가아닌 정적변수가 사용되지 않을 때 Warning이 발생합니다. -Wunused , -Wall에 포함   -Wunused-value 명시적으로 사용되지 않은 결과를 계산하는 경우 Warning이 발생합니다. -Wunused , -Wall에 포함   -Wcast-qual 포인터를 형변환 할 때 기존 type qualifier가 사라지는 경우 경고해줍니다(const char_을 char_로 형변환) -   -Wconversion 묵시적으로 타입을 변환하는 상황에서 값이 바뀔 가능성이 있는 경우 경고해줍니다(int temp = 0.3 등) -   -Wsign-conversion 부호있는 정수 표현식을 부호없는 정수 변수에 할당하는 것과 같이 정수 값의 부호를 변경할 수있는 변환에 대해 Warning이 발생합니다. -Wconversion 옵션에 의해 활성화됩니다.   -Wbad-function-cast 함수 콜이 매칭할 수 없는 타입에 캐스팅된 경우 Warning이 발생합니다. -   -Wwrite-strings constant 스트링을 non-const char* 포인터에 복사하는 경우 Warning이 발생합니다. 컴파일 타임에 const string을 변경하려는 문제를 찾을 수 있습니다. -   -Wconversion-null NULL 과 non-pointer 타입간의 변환에 대해 Warning이 발생합니다. Default enable   -Wextra -Wall에 의해 활성화되지 않는 추가적인 Warning flags(-Wclobbered -Wempty-body -Wignored-qualifiers -Wmissing-field-initializers -Wmissing-parameter-type (C only) -Wold-style-declaration (C only) -Woverride-init -Wsign-compare -Wtype-limits -Wuninitialized -Wunused-parameter (only with -Wunused or -Wall) -Wunused-but-set-parameter (only with -Wunused or -Wall))를 활성화합니다. -   -Wpacked 구조체에 packed 속성이 주어졌으나, 해당 레이아웃이나 크기에 영향이 없는 경우 Warning이 발생합니다. 이런 구조체는 아주 작은 이득을 위해 잘못 정렬될 수도 있습니다. -   -Wredundant-decls 유효범위 내에 동일한 오브젝트(변수 등)이 여러 번 선언된 경우 Warning이 발생합니다. -   -Waggregate-return 구조체 또는 공용체를 반환하는 함수를 선언하거나 호출 시 Warning이 발생합니다. 거의 사용하지 않는 Warning.. ANSI C 표준에 맞추기 위해 사용하나.. 흠,   -Wpointer-arith void의 크기나 함수의 크기를 갖고 연산(+/- 등)을 하는 경우 Warning이 발생합니다. -   -Wswitch-default switch 문에서 default case가 존재하지 않는 경우 Warning이 발생합니다. -   -Wundef 정의되지 않는 식별자가 #if, #endif 구문에서 사용된 경우 Warning이 발생합니다 -   -Wstrict-prototype 함수가 인자 형을 명시하지 않고 선언, 정의된 경우 Warning이 발생합니다. 즉, void test()와 같이 ()로 인자를 비워둔 경우 발생합니다. -   -Wfloat-equal 부동소수점 값이 ==, != 등의 등호로 비교된 경우 Warning이 발생합니다. -   -Wformat-y2k 2자리 연도를 출력하는 strftime()에 대해 Warning이 발생합니다. -   -Wshift-count-overflow Shift 연산이 타입의 크기와 같거나 큰 경우 Warning이 발생합니다. Default enable   -Wswitch-bool switch문이 boolean 타입의 인덱스를 가지는 경우 Warning이 발생합니다.    -Wno-conversion-null NULL과 non-pointer 타입 간의 변환에 대해 Warning이 발생하지 않도록 합니다. -Wconversion-null이 Default입니다.   -Wnested-externs extern 선언이 함수 안에 존재하는 경우 Warning이 발생합니다. -   -Wvarargs va_start와 같은 가변인자를 처리하는데 사용된 매크로의 의심스러운 사용에 대해 Warning이 발생합니다. Default enable   -Wunsuffixed-float-constants 접미사가 없는 부동상수에 대해 Warning이 발생합니다. -   -Wswitch-enum switch문에서 index로 enum을 사용한 경우에 enum의 멤버와 case의 수가 맞지 않을 때 Warning이 발생합니다. -   -Wshadow 지역변수가 다른 지역변수, 매개변수 등(shadow) 덮는 경우 Warning이 발생합니다.    -Wunreachable-code 어떠한 경우에도 실행할 수 없는 코드 라인이 존재하는 경우 Warning이 발생합니다. gcc 4.4 이상에서 제거됨   -Winline inline으로 선언된 함수가 inline이 불가능 경우 Warning이 발생합니다.    -funroll-loops for()와 같은 루프문을 풀어서 최적화 해주는 옵션으로, 코드를 크게 만들어주며 수행속도가 빨라질수도 아닐수도 있습니다.     감사합니다.\n"
},
{
	"uri": "/linux/compilelink/gcc_specific_attribute/",
	"title": "[gcc] 최적화 속성 사용하기",
	"tags": [],
	"description": "",
	"content": "gcc를 컴파일러로 사용할 시 -O2, -O3와 같은 최적화 옵션을 자주 사용하게 됩니다.\n특별한 경우에 특정 함수나 코드 구간에 대해서 특정 최적화 단계를 적용하고 싶다면 아래와 같이 진행합니다.\n함수에 최적화 적용하기 void __attribute__((optimize(\u0026#34;O0\u0026#34;))) func(void) { } 코드 범위에 최적화 적용하기 #pragma GCC push_options#pragma GCC optimize (\u0026#34;O0\u0026#34;) //Write your code  #pragma GCC pop_options감사합니다.\n"
},
{
	"uri": "/linux/compilelink/staticliblink/",
	"title": "정적 라이브러리 링크",
	"tags": [],
	"description": "",
	"content": "라이브러리 중 정적 라이브러리(static library)를 사용하는 경우가 종종 있다. 그리고 해당 라이브러리가 또 다른 (static library)를 Link 하는 경우가 있다. 이럴 때 문제가 발생하게 된다. 아래와 같이 어플리케이션이 필요로 하는 정적 라이브러리를 링크하게 되는데, 해당 라이브러리가 다른 정적 라이브러리를 링크하게 되는 경우이다.\nApplication \u0026ndash;\u0026gt; Static library 1 \u0026ndash;\u0026gt; Static library 2\nApplication은 Static library 1의 존재만 알 뿐 2의 존재는 알지도, 알 필요도 없다.\npkg-config를 이용한 경우 pc 파일에 정의 아래 libpalosalodp 의 pc.in 파일이다.\n# Package Information for pkg-config prefix=@prefix@ exec_prefix=${prefix} libdir=${exec_prefix}/lib includedir=${prefix}/include/ Name: libtest Description: test library Version: 0.0.1 Requires.private: libtest_internal \u0026gt;= 0.0.1 Libs: -L${libdir} -ltest Cflags: -I${includedir} \\  -I${includedir}/Include Requires.private 에서 libodp_internal_${sdktype} 에 대한 필요 정보를 명시하고, 다른 Application의 Makefile에서 pkg-config \u0026ndash;static 옵션을 붙여서 추가 시 해당 lib을 추가해준다.\nRequires.private 은 이 패키지에 필요한 패키지 목록을 나타내는 것으로 동적 링크된 실행 파일(static이 지정되지 않은 경우)에 대해 플래그 목록을 계산할 때 고려되지 않는다.\nRequires 사용하기 # Package Information for pkg-config prefix=@prefix@ exec_prefix=${prefix} libdir=${exec_prefix}/lib includedir=${prefix}/include/ Name: libtest Description: test library Version: 0.0.1 Requires: libtest_internal \u0026gt;= 0.0.1 Libs: -L${libdir} -ltest Cflags: -I${includedir} \\  -I${includedir}/Include Requires 옵션을 이용하여 포함시킨다.\nRequires와 Requires.private의 차이는 아래와 같다.\n  Requires: 패키지가 의존하여 사용하는 다른 패키지의 이름의 목록으로 공백으로 구분한다. 비교 연산자(=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=)를 사용하여 버전을 지정할 수도 있다.\n  Requires.private: 패키지가 의존하여 사용하는 다른 패키지의 이름의 목록으로 공백으로 구분한다. 단 Requires와 다르게 패키지 안에서만 사용하며 이 패키지를 가져다가 사용하는 애플리케이션에는 사용할 필요 없을 패키지를 나열한다. 버전을 지정하는 형식은 Requires와 동일하다.\n  하지만 정적 라이브러리를 링크하고 있는 상황이기 때문에, Requires를 사용하던지 Application은 pkg-config 에서 \u0026ndash;static 을 사용해야만 Requires.private에 정의된 패키지를 사용할 수 있다.\n"
},
{
	"uri": "/",
	"title": "Developer&#39;s Delight",
	"tags": [],
	"description": "",
	"content": "Developer's Delight Seungha Son   Samsung Electronics Software Engineer\n  Expert knowledge and hands-on experience of system programming, application developing, debugging and profiling and optimization based linux.\n  Programming skills in C (advanace level), and C++, Java, Python, Shell script (Intermediate level)\n  Interested in open-source, system architecture\n  "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]