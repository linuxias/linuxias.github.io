<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Developer&#39;s Delight</title>
    <link>/</link>
    <description>Recent content on Developer&#39;s Delight</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 30 Dec 2019 23:06:22 +0900</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1. Cgroup</title>
      <link>/container/cgroup/1.cgroup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/cgroup/1.cgroup/</guid>
      <description>cgroup은 단일 또는 태스크 단위의 프로세스 그룹에 대한 자원 할당을 제어하는 커널 모듈입니다. Cgroup은 Control group으로 처음 개발되었을 때는 group이 아니라 container란 용어를 사용했었습니다. 하지만 container란 용어는 너무 많은 의미를 내포하고 있다고 판단하여 지금의 group이만 이름으로 변경되었습니다.
현재 cgroup은 v1와 v2 두가지 버전이 공존하고 있습니다. v1의 서비스시템 중 일부는 v2에 포함되어 있는 상태입니다. 언젠가 v2만 남겠죠..?
cgroup 서브시스템 cgroup은 여러 개의 서브시스템으로 이루어져 있습니다. (아래 표에 모든 서브시스템을 작성한 것은 아니니, 유의해주세요.</description>
    </item>
    
    <item>
      <title>1. Namespace</title>
      <link>/container/namespace/1.what_is_namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/1.what_is_namespace/</guid>
      <description>Namespace 기술은 cgourp(Control Group)과 함께 컨테이너(Container) 솔루션을 구성하는 기술 중 하나입니다. 이번 글에서는 namespcae에 대해 정리한 후linux에서 제공하는 namespcae의 종류에 대해 정리하고자 합니다.
namespace는 전역 시스템 리소스를 추상화하여 전역 리소스의 자체 격리 인스턴스가있는 namespace 내의 프로세스에 표시 되도록합니다. 전역 리소스에 대한 변경은 namespace의 멤버, 즉 동일한 namespace를 가진 다른 프로세스에서 볼 수 있지만 다른 namespace를 가진 프로세스에서는 보이지 않습니다. namespcae를 사용하는 것은 컨테이너를 구현하는 것입니다.
   Namespace Constant Isolates     IPC CLONE_NEWIPC System V IPC, POSIX message queues   Network CLONE_NEWNET Network devices, stacks, ports, etc.</description>
    </item>
    
    <item>
      <title>2. blkio</title>
      <link>/container/cgroup/2.cgroup_blkio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/cgroup/2.cgroup_blkio/</guid>
      <description>Subsystem - blkio blkio 서브시스템은 특정 block device에 대한 접근을 제한하거나 제어하기 위한 서브시스템 입니다. 자세한 내용은 ** Documentation/cgroup-v1/blkio-controller.txt ** 를 참고해주세요.
예제 살펴보기 I/O 작업이 많은 몇몇의 어플리케이션이 하나의 서버에서 동작한다고 가정합니다. 각 어플리케이션에 대해 다른 우선순위와 I/O 대역폭을 설정해주는 예제를 살펴보겠습니다.
 cgroup 가상파일시스템을 마운트합니다.  $ sudo mkdir -p /cgroup/blkio $ sudo mount -t cgroup -o blkio blkio /cgroup/blkio 마운트 여부 확인하기. 아래 명령어를 수행해서 결과가 표시된다면 정상적으로 마운트되었습니다.</description>
    </item>
    
    <item>
      <title>2. PID Namespace</title>
      <link>/container/namespace/2_pid_namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/2_pid_namespace/</guid>
      <description>PID namespace는 프로세스 ID 공간을 격리 시킵니다. 이 말인 즉, 다른 PID namespace의 프로세스들은 같은 PID를 가질 수도 있음을 의미합니다. PID namespace들은 프로세스 집합의 종료, 재시작과 같은 기능을 제공하기 위한 컨테이너를 허용합니다. 또한 컨테이너를 새로운 호스트로 마이그레이션하는 등의 기능을 컨테이너가 제공할 수 있도록 해줍니다.
PID namepsace의 특이한 점은 새로운 PID namespace의 PID는 1 부터 시작한다는 것입니다. standalone 시스템과 동일하게 각 namespace의 시작 프로세스는 pid를 1번을 가지게됩니다. PID namespace를 사용하기 위해선 CONFIG_PID_NS 커널 옵션을 설정해야 합니다.</description>
    </item>
    
    <item>
      <title>3. memory</title>
      <link>/container/cgroup/3.cgroup_memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/cgroup/3.cgroup_memory/</guid>
      <description>Subsystem - memory memory 서브시스템은 cgroup에서 사용하는 메모리 자원에 대해 프로세스가 사용하는 메모리 양과 사용 가능한 메모리 자원을 컨트롤 할 수 있습니다. 또한 사용되는 메모리 자원에 대한 레포트도 자동으로 생성해주는 서브시스템입니다.
memory 서브시스템은 시스템으로부터 태스크의 그룹의 메모리 접근등의 동작을 격리화시킵니다. 이 서브시스템이 사용되는 경우는 다음과 같습니다.
 메모리 소모가 많은 어플리케이션을 격리하고 더 작은 어플리케이션으로 제한할 수 있습니다. mem=XXXX 설정을 통해 부팅하는 경우의 좋은 대안이 될 수 있습니다. 가상화 솔루션에서 원하는 메모리 양을 제어할 수 있습니다.</description>
    </item>
    
    <item>
      <title>3. User Namespace</title>
      <link>/container/namespace/3.user_namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/3.user_namespace/</guid>
      <description>먼저 이 글에서 사용한 코드는 linux kernel 4.16 임을 알려드립니다.
 User namespace는 시큐리티와 관련된 식별자 및 속성을 분리하며, 특히 User ID와 Group ID, 루트 디렉토리, Key, Capability를 분리합니다. 프로세스의 User, Group ID는 user namespace 내,외부적으로 다를수 있습니다. 특히 프로세스는 User namespace 외부에 권한이 없는 정상적인 User ID를 가질 수 있으며, 동시에 namepsace 내부에 User ID 0을 가질 수 있습니다. 즉, 프로세스에는 user namespace 내의 작업에 대한 전체 권한이 있지만 namespace 외부 작업에 대한 권한이 없습니다.</description>
    </item>
    
    <item>
      <title>4. cpu, cpuset, cpuaccet</title>
      <link>/container/cgroup/4.cpu.cpuset.cpuacct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/cgroup/4.cpu.cpuset.cpuacct/</guid>
      <description>Subsystem - cpu, cpuset 이번 글에서는 Cgroup의 서브시스템 중 cpu와 cpuset 에 대해 정리해보겠습니다.
cpu subsystem cpu 서브시스템은 cgroup 계층 및 해당 작업에 대한 CPU 시간을 스케쥴링 할 수 있습니다. 시스템이 busy 상태일 때 CPU 공유를 최소화 즉 사용량을 제한 할 수 있습니다. 이 서브시스템은 CPU에 cgroup 작업 액세스를 제공하기 위한 스케줄러(Documentation/scheduler/sched-design-CFS.txt)를 제공합니다.
cpuset subsystem cpuset 서브시스템은 개별 CPU 및 메모리 노드를 cgroup에 바인딩 하기 위한 서브시스템입니다. 리눅스의 testset 명령과 유사하게 CPU 코어를 할당 할 수 있는 서브시스템 입니다.</description>
    </item>
    
    <item>
      <title>4. QEMU</title>
      <link>/container/namespace/4.qemu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/4.qemu/</guid>
      <description>Introduction QEMU는 고속의 동적 바이너리 변환 기법을 사용하는 프로세서 에뮬레이터이자 가상화 하이퍼바이저 입니다. 여기서 바이너리 변환이란 하나의 Instruction Set을 다른 Instruction Set으로 번환해주는 처리과정을 말하며, 정적 또는 동적인 방법이 존재합니다.
QEMU에 대해 정리하기 앞서 QEMU와 KVM을 굉장히 많은 분들이 헷갈려 하시는데, 아래 블로그에 매우 자세하게 정리가 되어 있으니 참고하시면 좋을 것 같습니다.
[Qemu와 KVM의 개념 - 에뮬레이션과 가상화][http://blog.naver.com/PostView.nhn?blogId=alice_k106&amp;amp;logNo=221179347223&amp;amp;parentCategoryNo=7&amp;amp;categoryNo=&amp;amp;viewDate=&amp;amp;isShowPopularPosts=true&amp;amp;from=search]
이 글에서는 KVM이 아닌 QEMU에 관한 내용만 정리하려 합니다.
처음 QEMU 개발 시에는 x86 기반이 아닌 아키텍처에서 x86 기반의 리눅스 응용 프로그램을 실행하는 목적으로 개발되었다고 합니다.</description>
    </item>
    
    <item>
      <title>5. Mount namespace</title>
      <link>/container/namespace/5_mount_namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/5_mount_namespace/</guid>
      <description>mount namespace는 프로세스와 그 자식 프로세스에게 다른 파일시스템 마운트 포인트를 제공합니다. 각 namespace instance의 프로세스들에게 보여지는 마운트 포인트를 격리시키는 기능을 제공합니다. 이렇게 격리된 마운트 포인트는 각 프로세스에게 단일 디렉토리 구조로 보여지게됩니다.
처음 설치된 시스템에서는 기본적으로 모든 프로세스가 하나의 mount namespaece(기본 namespace)에 속하기 때문에 파일시스템를 마운트하거나 해제하는 등의 모든 사항을 확인 및 인지할 수 있습니다.
clone(2) 또는 unshare() 시스템 콜과 CLONE_NEWNS 플래그를 사용하여 새로운 프로세스를 생성하면 생성하는 프로세스의 mount namespace를 그대로 복사하여 생성하게 됩니다.</description>
    </item>
    
    <item>
      <title>6. UTS namespace</title>
      <link>/container/namespace/6.uts_namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/6.uts_namespace/</guid>
      <description>UTS(Unix TimeSharing) namespace는 리눅스 컨테이너가 ** hostname -f ** 명령어에 의해 반환된 결과 값인 자신의 식별자를 유지관리하기 위해 hostname과 domainname을 namespace 별로 격리해줍니다. 격리하는 대상은 구별을 위한 식별자가 됩니다. 단순하게 생각하면 hostname은 호스트 각각의 이름이고 domainname은 그룹의 이름입니다. 기본적으로 domainname을 설정하지 않았다면 none으로 표시됩니다.
UTS namespace로 분리할 수 있는 식별자는 sethostname(2)과 setdomainname(2)을 사용하여 설정되며 unname(2), gethostname(2) 및 getdomainname(2)을 사용하여 검색할 수 있습니다.
unshare 또는 clone 시스템 콜 호출 시에 CLONE_NEWUTS 플래그를 사용하면 새로운 UTS namespace를 생성하고 해당 namespace를 가진 프로세스를 생성할 수 있습니다.</description>
    </item>
    
    <item>
      <title>7. Cgroup Namespace</title>
      <link>/container/namespace/7.cgroup_namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/container/namespace/7.cgroup_namespace/</guid>
      <description>cgroup namespace는 프로세스의 cgroups의 뷰를 가상화 합니다.
각 cgroup 네임스페이스에는 고유한 cgroup 루트 디렉토리 세트가 있습니다. 그 루트 디렉토리는 /proc/[pid]/cgroup 파일의 해당 레코드에 표시되는 상대 위치의 베이스 위치입니다. clone(2) 또는 unshare(2) 시스템 콜에 CLONE_NEWCGROUP 플래그를 전달하여 새로운 cgroup namespace를 생성할 수 있습니다. 이렇게 생성된 namespace는 현재 cgroups 디렉토리가 새 namespace의 cgroup 루트 디렉토리가되는 새 cgroup namespace로 들어갑니다. 이 정책은 cgroup 버전 1,2 모두에 적용됩니다.
/proc/[pid]/cgroup 을 확인하면 표시되는 각 레코드의 세 번째 필드에 표시된 경로 이름은 해당 cgroup 계층에 대한 읽기 프로세스의 루트 디렉토리에 상대적인 위치입니다.</description>
    </item>
    
    <item>
      <title>프로그래밍 면접 이렇게 준비한다</title>
      <link>/books/readyforprogramminginterview/</link>
      <pubDate>Sun, 05 Jan 2020 03:43:45 +0900</pubDate>
      
      <guid>/books/readyforprogramminginterview/</guid>
      <description>목차
CHAPTER 1 구직을 시작하기 전에
너 자신을 알라
시장을 알라
팔릴 만한 능력을 계발하라
일 제대로 해내기
온라인 프로파일을 정돈하라
요약
CHAPTER 2 입사 지원 절차
회사 선택 및 접촉
면접 절차
리크루터의 역할
근무 조건 협상
요약
CHAPTER 3 전화 예비 면접
전화 예비 면접의 이해
전화 예비 면접 방법
전화 예비 면접 문제
요약
CHAPTER 4 프로그래밍 문제 접근법
절차
문제 해결
풀이 분석
요약
CHAPTER 5 연결 리스트</description>
    </item>
    
    <item>
      <title>[gcc] Warning 옵션</title>
      <link>/linux/compilelink/gcc_warning_option/</link>
      <pubDate>Mon, 30 Dec 2019 23:24:46 +0900</pubDate>
      
      <guid>/linux/compilelink/gcc_warning_option/</guid>
      <description>gcc 컴파일 옵션으로 많이 사용하는 -Wall , -Wextra 이외에 다양한 옵션들은 정리하고자 합니다.
   옵션 설명 특이사항     -fstack-usage 컴파일러가 프로그램에 대한 스택 사용 정보를 함수 단위로 출력하도록 합니다. 함수의 이름, 바이트 수 등이 표기됩니다. x   -Wframe-larger-than={len} 함수 프레임의 크기가 len을 넘어가면 Warning이 출력합니다. x   -Wstrict-overflow=n -fstrict-overflow가 활성화 되어있는 경우에만 활성화됩니다. 컴파일러가 signed 오버플로우가 일어나지 않을거라 가정하고 최적화를 진행하는 경우에 Warning이 발생합니다.</description>
    </item>
    
    <item>
      <title>[gcc] 최적화 속성 사용하기</title>
      <link>/linux/compilelink/gcc_specific_attribute/</link>
      <pubDate>Mon, 30 Dec 2019 23:23:27 +0900</pubDate>
      
      <guid>/linux/compilelink/gcc_specific_attribute/</guid>
      <description>gcc를 컴파일러로 사용할 시 -O2, -O3와 같은 최적화 옵션을 자주 사용하게 됩니다.
특별한 경우에 특정 함수나 코드 구간에 대해서 특정 최적화 단계를 적용하고 싶다면 아래와 같이 진행합니다.
함수에 최적화 적용하기 void __attribute__((optimize(&amp;#34;O0&amp;#34;))) func(void) { } 코드 범위에 최적화 적용하기 #pragma GCC push_options#pragma GCC optimize (&amp;#34;O0&amp;#34;) //Write your code  #pragma GCC pop_options감사합니다.</description>
    </item>
    
    <item>
      <title>정적 라이브러리 링크</title>
      <link>/linux/compilelink/staticliblink/</link>
      <pubDate>Mon, 30 Dec 2019 23:21:11 +0900</pubDate>
      
      <guid>/linux/compilelink/staticliblink/</guid>
      <description>라이브러리 중 정적 라이브러리(static library)를 사용하는 경우가 종종 있다. 그리고 해당 라이브러리가 또 다른 (static library)를 Link 하는 경우가 있다. 이럴 때 문제가 발생하게 된다. 아래와 같이 어플리케이션이 필요로 하는 정적 라이브러리를 링크하게 되는데, 해당 라이브러리가 다른 정적 라이브러리를 링크하게 되는 경우이다.
Application &amp;ndash;&amp;gt; Static library 1 &amp;ndash;&amp;gt; Static library 2
Application은 Static library 1의 존재만 알 뿐 2의 존재는 알지도, 알 필요도 없다.
pkg-config를 이용한 경우 pc 파일에 정의 아래 libpalosalodp 의 pc.</description>
    </item>
    
  </channel>
</rss>